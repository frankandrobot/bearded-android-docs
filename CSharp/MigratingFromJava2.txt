Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-01-08T14:59:47-05:00

====== MigratingFromJava2 ======
Created Wednesday 08 January 2014

===== Delegates =====
A **delegate** is a function pointer. Unlike function pointers in C or C++, delegates are object-oriented, type-safe, and secure.

==== Creating a Delegate ====
'''

//declare delegate
delegate void foobar(int i);

class Foo
{
    //these two will be passed as function ptrs
    public void delegate1(int i) { //... }
    public void delegate2(int i) { //... }
    
    //this is how you use a delegate as a parameter
    public callDelegate(foobar delegateMethod)
    {
        //call delegate with input 0
        delegateMethod(0);
    }
}

Foo foo = new Foo();

//create delegates
foobar delegate1 = new foobar(foo.delegate1);
foobar delegate2 = new foobar(foo.delegate2);

//invoke delegates directly
delegate1(1000);

//pass delegate to fuction
foo.callDelegate(delegate1);

//NOTE: you can also do chain delegates together!
foobar delegate3 = delegate1 + delegate2;

//calls delegate1 followed by delegate2
delegate3(100);
'''


==== Delegates vs Interfaces ====
With the exception of the neat function chaining shown above, you can get the same functionality by using an interface. In fact, in Java, that's the technique that's used to get function-pointer-like behavior. For example:

'''
//declare interface to use as "function pointer"
interface IFunctionPtr { void method(); }

//function to use as "function pointer"
public void functionPtr() { //... }

//accepts "function pointer" as param
public void callFunctionPtr(IFunctionPtr ptr)
{
    //call "function pointer" interface
    ptr.method();
}

//create "function pointer"
IFunctionPtr javaFunctionPtr = new IFunctionPtr() {
    @Override
    public void method() { functionPtr(); }
};

//invoke "function pointer" directly
javaFunctionPtr.method();

//pass "function pointer" to function
callFunctionPtr(javaFunctionPtr);
'''

Unfortunately, other than the neat function chaining described earlier, I don't see any reason to use a delegate except to get more compact code (you don't have to wrap the method with an anonymous class). 

Note that there are times when it does //not //make sense to use a delegate:

* You'll call a set of related methods
* You need access to the object the method is defined on. Ex: The caller of the interface wants to cast to or from the interface type to obtain other interfaces or classes.

===== Inheritance =====
In Java, methods are //virtual //by default. You make them non-virtual with the ''final'' keyword. In C#, methods are //not //virtual by default. You must explicitly make them virtual with the ''virtual'' keyword. (See the ''override''/''virtual'' keywords in [[MigratingFromJava1]].)

An explanation via code:

'''
class Base
{
    public void method1() { //... }
}

Base base = new Base();
Derived derived = new Derived(); //extends base
Base bd = new Derived();

|                   | Java                  | C#                    |
|-------------------|-----------------------|-----------------------|
| base.method1()    | calls Base#method1    | calls Base#method1    |
| derived.method1() | calls Derived#method1 | calls Derived#method1 |
| bd.method1()      | calls Derived#method1 | calls Base#method1    |

//in Java, by default, polymorphism (which is slow) kicks in
//in C#, you must explicitly enable polymorphism
'''


===== Events =====

===== Multi-Threading =====

===== Unsafe Mode =====

===== LINQ =====

===== Resources =====
* [[http://msdn.microsoft.com/en-us/library/aa288459(v=vs.71).aspx|All about delegates]]
* [[http://msdn.microsoft.com/en-us/library/aa645739(v=vs.71).aspx|Events Tutorial]]
