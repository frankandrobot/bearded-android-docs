Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2013-12-12T13:50:58-05:00

====== BatchModeBackPropagation ======
Created Thursday 12 December 2013

Step 0. Initialize the weights.

Step 1. Pick values for the learning and momentum parameters. See backpropagation parameters. 

Step 2. For each training example:
* 2a. Perform the forward propagation. For each layer, store each neuron's induced local field and value of its impulse function.
* 2b. Calculate and store the gradients of each neuron starting with the output layer.
* 2c. Update the cumulative learning term for each weight of each neuron starting with the output layer. Discard the stored induced local fields, impulse functions, and gradients.

Step 3. Adjust each weight using its cumulative learning term and momentum term. Make sure to store the values of the previous weights.
Step 4. Construct the error function from the training examples.

Step 5. Repeat steps 2--4 until the error is smaller than a pre-selected value. If the error never converges, pick new backpropagation parameters and restart from Step 1.

**Notes:** 
1. Its called the //backpropagation //algorithm because you start from the output layer (Steps 2b and c) and work backwards to the input layer.
2. Steps 2--4 are one iteration of the backpropagation algorithm.
3. A common mistake is adjust the weights before cycling through all the examples. You need to calculate a weight's //cumulative //learning term (from all the examples) before updating it.

===== Required Memory and Data Structures =====
You'll need data structure(s) to store:

* induced local fields and the values of the impulse functions of its neurons //for each layer//. Since these are just used to find the gradients and the learning terms, you do not need to store this data for each example. The data structure(s) can be shared by each example.
* gradients of the neurons of each layer. //Ditto.// Since these are just used to find the learning terms, you do not need to store this data for each example. The data structure(s) can be shared by each example.
* learning terms for the weights of the neurons in each layer. These represent the //cumulative //learning terms of all examples, so all you need is one set of data structure(s) per iteration.
* //previous //weight values (these are used by the momentum term). You do not need to store the complete history of the weights, just the previous values.

===== Initalizing the Weights =====
"Pick the weights from a uniform distribution whose mean is zero and whose variance is chosen to make the standard deviation of the induced local fields of the neurons (See [[:NeuralNetworks|neural networks]]) lie at //the transition between the linear and saturated parts of the //[[NeuralNetworks:ActivationFunction|activation function]]" (I have no idea what the emphasized parts means.)

Most researchers initialize the weights to random values between 0 and 1. I use a gaussian with mean 0.5 and standard deviation 1.

===== Performing the Forward Propagation =====
* Given a training input `bb x_i`, calculate the output of the neural network. 
* Make sure to store the induced local fields and the values of the impulse functions of each neuron in each layer.

===== Constructing the Gradients (`delta"s"`) =====
This is how to compute the local gradients (`delta"s"`) of each neuron:

* Let `N_j` be neuron `j`.
* Let `L` be the output layer. 
* Let `v_j^((l))` be the induced local field of `N_j` in layer `l`. 
* Let `o_j^((l))` be the output (value of the impulse function) of `N_j` in layer `l`.
* Let `gamma_j^((l))` be the derivative of `N_j`s [[NeuralNetworks:ActivationFunction|activation function]].
* Let weight `w_(kj)^((l))` connect `N_k` in layer `l` to `N_j` in the previous layer.
* (In general, let a superscript `l` denote layer `l`.)

**Note: **`gamma_k` is a function. `v_j` and `o_j` are real numbers.

Define the local gradient `delta_j^((l))` of neuron `j` recursively as follows:

* for neuron `N_j` in output layer `L`, `delta_k^((L)) = ( t_j - o_j^((L)) ) xx gamma_j^((L)) ( v_j^((L)) )`
* for neuron `N_j` in hidden layer `l`, `delta_k^((l)) = gamma_j^((l)) ( v_j^((l)) ) xx sum_k delta_k^((l+1)) xx w_(kj)^((l+1))`

where the summation `sum_k` is over the neurons in layer `(l+1)` and weight `w_(kj)^((l+1))` connects `N_k` in layer `(l+1)` to `N_j` in layer `l`. 

**Note: **If its not clear, `gamma_j^((l)) ( v_j^((l)) )` is the derivative of the activation function at neuron `N_j`s induced local field. It's not a product.

A diagram will help:

'''
Layer l               Layer (l+1)
neuron 1              neuron 1, gradient 1
neuron 2            / neuron 2, gradient 2
...               /   ...
...           w_1j    ...
...           /       ...
...         /         ... 
...       /           ...
neuron j ----w_kj---> neuron k, gradient k
'''

In other words, for a hidden neuron `N_j` in layer `l`, its gradient is the product of (a) the derivate of the activation function at its induced local field and (b) the sum of the product of the gradients in the //next //layer and the weights that connect `N_j` to that gradient's neuron.

**Note:**
1. Its now clear why we needed to store the induced local fields and the values of its impulse functions---calculating these values dynamically significantly reduces the performance of the algorithm.
2. Don't forget to store the values of the `delta"s"` which will be needed in the next step.

===== Constructing the Learning Terms =====
Up to this point, our notation hasn't taken into account the training examples `{bb x(i), bb t(i)}`. We'll do this now by appending a term with `(i)` to denote the value for the ith training example. Ex: `sigma_j^((l))(i)` is the gradient for neuron `N_j` in layer `l` when the network is fed input `bb x(i)` (the ith training example).

**Note: **Neuron `N_j` in layer `l` isn't necessarily fed input `bb x(i)`. //The network is fed input `bb x(i)` and that in turn completely determines the inputs to neuron `N_j^((l))`.//

This is how we calculate the learning terms:

* Let `{bb x(i), bb t(i)}` be the training examples. `bb x(i)` is a vector `(x_1(i), ..., x_n(i))`.
* Let `eta` be the learning parameter.
* Let `o_j^((l))(i)` be the output (value of the impulse function) of neuron `N_j^((l))` when the network is fed input `bb x(i)`.
* Let weight `w_(kj)^((l))` connect `N_k` in layer `l` to `N_j` in the previous layer. 
* Let weight `w_(j0)` be the bias for all `j`.
* Let `sigma_j^((l))(i)` be the gradient of neuron `N_j^((l))` when the network is fed input `bb x(i)`.

Define `bb y^((l))(i)` as the output from neuron `N_j^((l))` when the network is fed input `bb x(i)`:

* For `l = 0` (input layer), let `y_j^((0))(i) = x_j(i)` (the "output" of the input layer is just the input). 
* For `l > 0`, let `y_j^((l))(i) = o_j^((l))(i)` (the output of neuron `N_j` in layer `l`).
* For all `l`, let `y_0^((l))(i) = +1` (`y_0` gets mapped to the bias).

**Note:** 
1. `y_j^((l))(i)` can be thought of as the //input //that's fed to the //next //layer `(l+1)`.
2. Since `w_(j0)` is always the bias, the output of neuron `N_j` in layer `l` with weights `bb w` and activation function `phi` is just `\ phi(bb y^((l-1))(i) * bb w) = phi(sum_i y_i^((l-1))(i) w_(ji))` where the sum `sum_i` is over neurons in the previous layer.

The learning term for weight `w_(kj)` in layer `l` //and// //the ith training example// is:

`\ Delta w_(kj)^((l))(i) = eta sigma_k^((l))(i) y_j^((l-1))(i)`

Each weight will have a different learning term for each example//.// **For each weight `w_(kj)^((l))`, store the sum of all its learning terms for all the training examples, `sum_i Delta w_(kj)^((l))(i)`. **This cumulative sum is what's actually used to adjust the weight. 

**Note:**
1. Wait until you have the total sum `sum_i Delta w_(kj)^((l))(i)` from all the training examples before adjusting the weights. 
2. Its now clear why we needed to store the values of the impulse functions and the gradients---calculating these values dynamically significantly reduces the performance of the algorithm.

===== Adjusting the Weights =====
This is how to adjust the weights:

* Let `w_(kj)^(**(l))` be the //previous// value of the weight. 
* If there is no previous value, let `w_(kj)^(**(l)) = 0`.
* Let `sum_i Delta w_(kj)^((l))(i)` be the cumulative sum of the learning terms for `w_(kj)^((l))` for all the training examples. 
* Let `alpha` be the momentum term.

Adjust the weights using this formula:

`\ w_(kj)^((l)) = w_(kj)^((l)) + alpha w_(kj)^(**(l)) + sum_i Delta w_(kj)^((l))(i)`
`\ \ \ \ = w_(kj)^((l)) + alpha w_(kj)^(**(l)) + eta sum_i sigma_k^((l))(i) y_j^((l-1))(i)`

**Note: **`alpha w_(kj)^(**(l))` is the momentum term.

===== Constructing the Error Function =====
* Let `{bb x(i), bb t(i)}` be the `p` training examples. 
* Let `bb o(i)` be the actual output of the network for training input `bb x(i)`. 
**Note:**
1. Each `bb x(i)` and `bb t(i)` are vectors, `bb x(i) = (x_1(i), ...,  x_n(i))` and `bb t(i) = (t_1(i), ..., t_n(i))`. 
2. Each `t_j(i)` is the expected output of the ith training example for the jth neuron in the output layer.
3. `bb o(i)` is a vector `o_1(i), ..., o_n(i)`.
4. `o_j(i)` is the output (value of the impulse function) of neuron `N_j` in the output layer for input `bb x(i)`. 

With these definitions, `bb o(i) - bb t(i)` is the difference in the expected and actual values. We seek to minimize these differences for all training examples:

For each training example `i`, construct the error `E_i`

`\ E_i = 1/2 ||bb o(i) - bb t(i)||^2`

where `||*||` is the [[NeuralNetworks:Appendix:EuclidianDistance|euclidian distance]].  Since we're dealing with vectors, each `E_i` actually looks like this:

`\ E_i = 1/2 (o_1(i) - t_1(i))^2 + cdots + (o_n(i) - t_n(i))^2`

Construct the total error `E` of the network for all training examples:

`\ E = sum_i^p E_i = 1/2 sum_i^p ||bb o(i) - bb t(i)||^2 = 1/2 sum_i^p (o_1(i) - t_1(i))^2 + cdots + (o_n(i) - t_n(i))^2`

Repeat another iteration of the backpropagation algorithm until the error is less than a pre-selected amount.

====== Troubleshooting ======
* Unit test, unit test, unit test. You'll be suprised how easy it is to introduce a typo that breaks your implementation.
* The error never converges? Make sure you know how the [[Parameters|backpropagation parameters]] work.
